---
interface Props {
	targetId?: string;
	stopTargetId?: string;
	topOffset?: number;
	bottomOffset?: number;
	triggerDistance?: number;
	triggerDistanceBottom?: number;
	color?: string;
	parallaxSpeed?: number;
}

const {
	targetId = 'page-content',
	stopTargetId,
	topOffset = 500,
	bottomOffset = -450,
	triggerDistance = 500,
	triggerDistanceBottom = 500,
	color = 'rgb(244, 243, 243)',
	parallaxSpeed = 0.3
} = Astro.props;

const hasOverlay = Astro.slots.has('overlay');
---

<canvas
	id="bg-canvas"
	class="fixed top-0 left-0 w-full min-h-lvh pointer-events-none -z-1000"
	data-target-id={targetId}
	data-stop-target-id={stopTargetId}
	data-top-offset={topOffset}
	data-bottom-offset={bottomOffset}
	data-trigger-distance={triggerDistance}
	data-trigger-distance-bottom={triggerDistanceBottom}
	data-color={color}
	data-parallax-speed={parallaxSpeed}
	aria-hidden="true"
	role="presentation"
></canvas>

{hasOverlay && (
	<div
		id="bg-canvas-overlay"
		class="fixed inset-0 pointer-events-none z-99999 opacity-0 transition-opacity duration-500 flex items-center justify-center"
		aria-hidden="true"
	>
		<slot name="overlay" />
	</div>
)}

<script is:inline>
  // État global sur window pour persister entre les navigations
  if (!window._bgCanvas) {
    window._bgCanvas = {
      lenisHandler: null,
      scrollHandler: null,
      resizeHandler: null,
      pixels: [],
      // Spatial grid: Map<gridKey, true> pour O(1) lookup
      occupiedGrid: new Map(),
      isFullyCovered: false,
      overlayStartScrollY: 0,
      lastWidth: window.innerWidth,
      resizeTimeout: undefined,
      pendingRender: false
    };
  }

  function initBackgroundCanvas() {
    var state = window._bgCanvas;

    // Cleanup previous
    if (state.lenisHandler && window.lenis) {
      window.lenis.off('scroll', state.lenisHandler);
    }
    if (state.scrollHandler) {
      window.removeEventListener('scroll', state.scrollHandler);
    }
    if (state.resizeHandler) {
      window.removeEventListener('resize', state.resizeHandler);
    }
    clearTimeout(state.resizeTimeout);

    var canvas = document.getElementById('bg-canvas');
    if (!canvas) return;

    var ctx = canvas.getContext('2d');
    if (!ctx) return;

    var overlay = document.getElementById('bg-canvas-overlay');
    var targetId = canvas.getAttribute('data-target-id') || 'projects';
    var stopTargetId = canvas.getAttribute('data-stop-target-id') || null;
    var topOffset = Number(canvas.getAttribute('data-top-offset')) || 500;
    var bottomOffset = Number(canvas.getAttribute('data-bottom-offset')) || -450;
    var triggerDistance = Number(canvas.getAttribute('data-trigger-distance')) || 500;
    var pixelColor = canvas.getAttribute('data-color') || 'rgb(244, 243, 243)';
    var parallaxSpeed = Number(canvas.getAttribute('data-parallax-speed')) || 0.3;

    // Reset state
    state.pixels = [];
    state.occupiedGrid.clear();
    state.lastWidth = window.innerWidth;
    state.isFullyCovered = false;
    state.overlayStartScrollY = 0;
    state.pendingRender = false;

    var pixelSize = Math.floor(window.innerWidth / 8);
    var cols = 0;
    var rows = 0;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      pixelSize = Math.floor(window.innerWidth / 8);
      cols = Math.floor(canvas.width / pixelSize) + 1;
      rows = Math.floor(canvas.height / pixelSize) + 1;
    }

    function updateOverlay(progress, scrollY) {
      if (!overlay) return;

      var wasFullyCovered = state.isFullyCovered;
      state.isFullyCovered = progress >= 0.98;

      if (state.isFullyCovered && !wasFullyCovered) {
        state.overlayStartScrollY = scrollY;
      }

      if (state.isFullyCovered) {
        overlay.style.opacity = '1';
        var scrollDelta = scrollY - state.overlayStartScrollY;
        var parallaxOffset = scrollDelta * parallaxSpeed;
        overlay.style.transform = 'translateY(' + (-parallaxOffset) + 'px)';
      } else {
        overlay.style.opacity = '0';
        overlay.style.transform = 'translateY(0)';
      }
    }

    function getProjectSectionPosition() {
      var projectSection = document.getElementById(targetId);
      if (!projectSection) return null;
      var rect = projectSection.getBoundingClientRect();
      return rect.top + window.scrollY;
    }

    function getScrollY() {
      return window.lenis ? window.lenis.scroll : window.scrollY;
    }

    function isInAnimationZone() {
      var scrollY = getScrollY();
      var viewportHeight = window.innerHeight;
      var projectPos = getProjectSectionPosition();
      if (!projectPos) return false;

      var projectSection = document.getElementById(targetId);
      if (!projectSection) return false;

      var projectRect = projectSection.getBoundingClientRect();
      var projectEnd = projectRect.bottom + window.scrollY;
      var startZone = projectPos + topOffset - triggerDistance;

      var endZone = projectEnd + bottomOffset;
      if (stopTargetId) {
        var stopSection = document.getElementById(stopTargetId);
        if (stopSection) {
          var stopRect = stopSection.getBoundingClientRect();
          var stopPos = stopRect.top + window.scrollY;
          endZone = stopPos + bottomOffset - viewportHeight;
        }
      }

      return (scrollY + viewportHeight) >= startZone && scrollY <= endZone;
    }

    // Spatial grid helpers - O(1) lookup au lieu de O(n) avec string keys
    function gridKey(col, row) {
      return (row << 16) | col; // Combine en un seul nombre
    }

    function updatePixels() {
      var scrollY = getScrollY();
      var viewportHeight = window.innerHeight;
      var projectPos = getProjectSectionPosition();
      if (!projectPos) {
        state.pixels = [];
        state.occupiedGrid.clear();
        return;
      }

      var adjustedProjectPos = projectPos + topOffset;
      var distanceToProject = adjustedProjectPos - (scrollY + viewportHeight);
      var progressIn = Math.max(0, Math.min(1, 1 - distanceToProject / triggerDistance));
      var finalProgress = progressIn;
      var isExitingTop = scrollY + viewportHeight < adjustedProjectPos && progressIn < 1;

      updateOverlay(finalProgress, scrollY);

      if (finalProgress === 0) {
        state.pixels = [];
        state.occupiedGrid.clear();
        return;
      }

      var maxPixels = cols * rows;
      var targetPixelCount = Math.floor(maxPixels * finalProgress);

      // Construire la liste des positions disponibles avec spatial grid
      var availablePositions = [];
      for (var row = 0; row < rows; row++) {
        for (var col = 0; col < cols; col++) {
          var key = gridKey(col, row);
          if (!state.occupiedGrid.has(key)) {
            availablePositions.push({ col: col, row: row, y: row * pixelSize });
          }
        }
      }

      // Tri par Y avec randomisation (Fisher-Yates partiel pour perf)
      var len = availablePositions.length;
      if (len > 0) {
        // Tri simple par Y descendant avec perturbation
        availablePositions.sort(function(a, b) {
          return (b.y + Math.random() * 200) - (a.y + Math.random() * 200);
        });
      }

      var pixelsToAdd = targetPixelCount - state.pixels.length;
      if (pixelsToAdd > 0) {
        var toAdd = Math.min(pixelsToAdd, availablePositions.length);
        for (var i = 0; i < toAdd; i++) {
          var pos = availablePositions[i];
          var x = pos.col * pixelSize;
          var y = pos.row * pixelSize;
          state.pixels.push({ x: x, y: y, col: pos.col, row: pos.row });
          state.occupiedGrid.set(gridKey(pos.col, pos.row), true);
        }
      } else if (pixelsToAdd < 0) {
        // Trier les pixels existants pour retirer ceux du haut ou du bas
        state.pixels.sort(function(a, b) {
          var randomWeight = 200;
          if (isExitingTop) {
            return (-a.y + Math.random() * randomWeight) - (-b.y + Math.random() * randomWeight);
          } else {
            return (a.y + Math.random() * randomWeight) - (b.y + Math.random() * randomWeight);
          }
        });
        // Retirer les pixels en trop et mettre à jour la grille
        var removed = state.pixels.splice(targetPixelCount);
        for (var j = 0; j < removed.length; j++) {
          state.occupiedGrid.delete(gridKey(removed[j].col, removed[j].row));
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = pixelColor;
      var pixels = state.pixels;
      for (var i = 0; i < pixels.length; i++) {
        ctx.fillRect(pixels[i].x, pixels[i].y, pixelSize, pixelSize);
      }
    }

    function render() {
      if (!isInAnimationZone()) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        state.pixels = [];
        state.occupiedGrid.clear();
        return;
      }
      updatePixels();
      draw();
    }

    // Handler scroll unifié (Lenis ou natif)
    function onScroll() {
      if (!state.pendingRender) {
        state.pendingRender = true;
        requestAnimationFrame(function() {
          render();
          state.pendingRender = false;
        });
      }
    }

    // Setup listeners
    state.resizeHandler = function() {
      var currentWidth = window.innerWidth;
      if (currentWidth === state.lastWidth) return;

      state.lastWidth = currentWidth;
      clearTimeout(state.resizeTimeout);

      state.resizeTimeout = setTimeout(function() {
        resizeCanvas();
        state.pixels = [];
        state.occupiedGrid.clear();
        render();
      }, 200);
    };

    state.lenisHandler = onScroll;
    state.scrollHandler = onScroll;

    window.addEventListener('resize', state.resizeHandler);

    // Utiliser Lenis si disponible, sinon scroll natif
    if (window.lenis) {
      window.lenis.on('scroll', state.lenisHandler);
    } else {
      window.addEventListener('scroll', state.scrollHandler, { passive: true });
      // Réessayer d'attacher à Lenis quand il sera prêt
      var checkLenis = setInterval(function() {
        if (window.lenis) {
          window.removeEventListener('scroll', state.scrollHandler);
          window.lenis.on('scroll', state.lenisHandler);
          clearInterval(checkLenis);
        }
      }, 500);
      // Arrêter après 5 secondes
      setTimeout(function() { clearInterval(checkLenis); }, 5000);
    }

    resizeCanvas();
    render();
  }

  // Initialiser au chargement et après chaque navigation
  if (!window._bgCanvasListenerAdded) {
    window._bgCanvasListenerAdded = true;
    document.addEventListener('astro:page-load', initBackgroundCanvas);
  }

  // Toujours initialiser (le script inline s'exécute à chaque page)
  initBackgroundCanvas();
</script>
