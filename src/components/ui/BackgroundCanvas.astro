---
interface Props {
	targetId?: string;
	stopTargetId?: string;
	topOffset?: number;
	bottomOffset?: number;
	triggerDistance?: number;
	triggerDistanceBottom?: number;
	color?: string;
	parallaxSpeed?: number;
}

const {
	targetId = 'page-content',
	stopTargetId,
	topOffset = 500,
	bottomOffset = -450,
	triggerDistance = 500,
	triggerDistanceBottom = 500,
	color = 'rgb(244, 243, 243)',
	parallaxSpeed = 0.3
} = Astro.props;

const hasOverlay = Astro.slots.has('overlay');
---

<canvas
	id="bg-canvas"
	class="fixed top-0 left-0 w-full min-h-lvh pointer-events-none -z-1000"
	data-target-id={targetId}
	data-stop-target-id={stopTargetId}
	data-top-offset={topOffset}
	data-bottom-offset={bottomOffset}
	data-trigger-distance={triggerDistance}
	data-trigger-distance-bottom={triggerDistanceBottom}
	data-color={color}
	data-parallax-speed={parallaxSpeed}
	aria-hidden="true"
	role="presentation"
></canvas>

{hasOverlay && (
	<div
		id="bg-canvas-overlay"
		class="fixed inset-0 pointer-events-none z-99999 opacity-0 transition-opacity duration-500 flex items-center justify-center"
		aria-hidden="true"
	>
		<slot name="overlay" />
	</div>
)}

<script is:inline>
  // État global sur window pour persister entre les navigations
  if (!window._bgCanvas) {
    window._bgCanvas = {
      animationId: null,
      scrollHandler: null,
      resizeHandler: null,
      isAnimating: false,
      pixels: [],
      isFullyCovered: false,
      overlayStartScrollY: 0,
      lastWidth: window.innerWidth,
      resizeTimeout: undefined
    };
  }

  function initBackgroundCanvas() {
    const state = window._bgCanvas;

    // Cleanup previous
    if (state.animationId !== null) {
      cancelAnimationFrame(state.animationId);
      state.animationId = null;
      state.isAnimating = false;
    }
    if (state.scrollHandler) {
      window.removeEventListener('scroll', state.scrollHandler);
    }
    if (state.resizeHandler) {
      window.removeEventListener('resize', state.resizeHandler);
    }
    clearTimeout(state.resizeTimeout);

    const canvas = document.getElementById('bg-canvas');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const overlay = document.getElementById('bg-canvas-overlay');
    const targetId = canvas.getAttribute('data-target-id') || 'projects';
    const stopTargetId = canvas.getAttribute('data-stop-target-id') || null;
    const topOffset = Number(canvas.getAttribute('data-top-offset')) || 500;
    const bottomOffset = Number(canvas.getAttribute('data-bottom-offset')) || -450;
    const triggerDistance = Number(canvas.getAttribute('data-trigger-distance')) || 500;
    const pixelColor = canvas.getAttribute('data-color') || 'rgb(244, 243, 243)';
    const parallaxSpeed = Number(canvas.getAttribute('data-parallax-speed')) || 0.3;

    // Reset state
    state.pixels = [];
    state.lastWidth = window.innerWidth;
    state.isFullyCovered = false;
    state.overlayStartScrollY = 0;
    state.isAnimating = false;

    let pixelSize = Math.floor(window.innerWidth / 8);

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      pixelSize = Math.floor(window.innerWidth / 8);
    }

    function updateOverlay(progress, scrollY) {
      if (!overlay) return;

      const wasFullyCovered = state.isFullyCovered;
      state.isFullyCovered = progress >= 0.98;

      if (state.isFullyCovered && !wasFullyCovered) {
        state.overlayStartScrollY = scrollY;
      }

      if (state.isFullyCovered) {
        overlay.style.opacity = '1';
        const scrollDelta = scrollY - state.overlayStartScrollY;
        const parallaxOffset = scrollDelta * parallaxSpeed;
        overlay.style.transform = `translateY(${-parallaxOffset}px)`;
      } else {
        overlay.style.opacity = '0';
        overlay.style.transform = 'translateY(0)';
      }
    }

    function getProjectSectionPosition() {
      const projectSection = document.getElementById(targetId);
      if (!projectSection) return null;
      const rect = projectSection.getBoundingClientRect();
      return rect.top + window.scrollY;
    }

    function isInAnimationZone() {
      const scrollY = window.scrollY;
      const viewportHeight = window.innerHeight;
      const projectPos = getProjectSectionPosition();
      if (!projectPos) return false;

      const projectSection = document.getElementById(targetId);
      if (!projectSection) return false;

      const projectRect = projectSection.getBoundingClientRect();
      const projectEnd = projectRect.bottom + window.scrollY;
      const startZone = projectPos + topOffset - triggerDistance;

      let endZone = projectEnd + bottomOffset;
      if (stopTargetId) {
        const stopSection = document.getElementById(stopTargetId);
        if (stopSection) {
          const stopRect = stopSection.getBoundingClientRect();
          const stopPos = stopRect.top + window.scrollY;
          endZone = stopPos + bottomOffset - viewportHeight;
        }
      }

      return (scrollY + viewportHeight) >= startZone && scrollY <= endZone;
    }

    function updatePixels() {
      const scrollY = window.scrollY;
      const viewportHeight = window.innerHeight;
      const projectPos = getProjectSectionPosition();
      if (!projectPos) {
        state.pixels = [];
        return;
      }

      const adjustedProjectPos = projectPos + topOffset;
      const distanceToProject = adjustedProjectPos - (scrollY + viewportHeight);
      const progressIn = Math.max(0, Math.min(1, 1 - distanceToProject / triggerDistance));
      const finalProgress = progressIn;
      const isExitingTop = scrollY + viewportHeight < adjustedProjectPos && progressIn < 1;

      updateOverlay(finalProgress, scrollY);

      if (finalProgress === 0) {
        state.pixels = [];
        return;
      }

      const cols = Math.floor(canvas.width / pixelSize) + 1;
      const rows = Math.floor(canvas.height / pixelSize) + 1;
      const maxPixels = cols * rows;
      const targetPixelCount = Math.floor(maxPixels * finalProgress);
      const occupiedPositions = new Set(state.pixels.map(p => `${p.x},${p.y}`));
      const availablePositions = [];

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const x = col * pixelSize;
          const y = row * pixelSize;
          if (!occupiedPositions.has(`${x},${y}`)) {
            availablePositions.push({x, y});
          }
        }
      }

      availablePositions.sort((a, b) => {
        const randomWeight = 200;
        const scoreA = a.y - Math.random() * randomWeight;
        const scoreB = b.y - Math.random() * randomWeight;
        return scoreB - scoreA;
      });

      const pixelsToAdd = targetPixelCount - state.pixels.length;
      if (pixelsToAdd > 0) {
        for (let i = 0; i < Math.min(pixelsToAdd, availablePositions.length); i++) {
          state.pixels.push({
            x: availablePositions[i].x,
            y: availablePositions[i].y,
            alpha: 1
          });
        }
      } else if (pixelsToAdd < 0) {
        state.pixels.sort((a, b) => {
          const randomWeight = 200;
          if (isExitingTop) {
            return (-a.y + Math.random() * randomWeight) - (-b.y + Math.random() * randomWeight);
          } else {
            return (a.y + Math.random() * randomWeight) - (b.y + Math.random() * randomWeight);
          }
        });
        state.pixels.length = targetPixelCount;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      state.pixels.forEach(pixel => {
        ctx.fillStyle = pixelColor;
        ctx.fillRect(pixel.x, pixel.y, pixelSize, pixelSize);
      });
    }

    function stopAnimation() {
      if (state.animationId !== null) {
        cancelAnimationFrame(state.animationId);
        state.animationId = null;
        state.isAnimating = false;
      }
    }

    function animate() {
      if (!isInAnimationZone()) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        state.pixels = [];
        stopAnimation();
        return;
      }

      updatePixels();
      draw();
      state.animationId = requestAnimationFrame(animate);
    }

    function startAnimation() {
      if (!state.isAnimating) {
        state.isAnimating = true;
        animate();
      }
    }

    function checkAndToggleAnimation() {
      if (isInAnimationZone()) {
        startAnimation();
      }
    }

    // Setup listeners
    state.resizeHandler = () => {
      const currentWidth = window.innerWidth;
      if (currentWidth === state.lastWidth) return;

      state.lastWidth = currentWidth;
      clearTimeout(state.resizeTimeout);

      state.resizeTimeout = setTimeout(() => {
        resizeCanvas();
        state.pixels = [];
      }, 200);
    };

    state.scrollHandler = () => {
      if (!state.isAnimating) {
        checkAndToggleAnimation();
      }
    };

    window.addEventListener('resize', state.resizeHandler);
    window.addEventListener('scroll', state.scrollHandler, { passive: true });

    resizeCanvas();
    checkAndToggleAnimation();
  }

  // Initialiser au chargement et après chaque navigation
  // Éviter d'ajouter plusieurs event listeners
  if (!window._bgCanvasListenerAdded) {
    window._bgCanvasListenerAdded = true;
    document.addEventListener('astro:page-load', initBackgroundCanvas);
  }

  // Toujours initialiser (le script inline s'exécute à chaque page)
  initBackgroundCanvas();
</script>
