---
interface Props {
	targetId?: string;
	stopTargetId?: string;
	topOffset?: number;
	bottomOffset?: number;
	triggerDistance?: number;
	triggerDistanceBottom?: number;
	color?: string;
}

const {
	targetId = 'page-content',
	stopTargetId,
	topOffset = 500,
	bottomOffset = -450,
	triggerDistance = 500,
	triggerDistanceBottom = 500,
	color = 'rgb(244, 243, 243)'
} = Astro.props;
---

<canvas
	id="bg-canvas"
	class="fixed top-0 left-0 w-full min-h-lvh pointer-events-none -z-1000"
	data-target-id={targetId}
	data-stop-target-id={stopTargetId}
	data-top-offset={topOffset}
	data-bottom-offset={bottomOffset}
	data-trigger-distance={triggerDistance}
	data-trigger-distance-bottom={triggerDistanceBottom}
	data-color={color}
	aria-hidden="true"
	role="presentation"
></canvas>

<script>
  let canvas: HTMLCanvasElement;
  let ctx: CanvasRenderingContext2D;
  let targetId: string;
  let stopTargetId: string | null;
  let topOffset: number;
  let bottomOffset: number;
  let triggerDistance: number;
  let triggerDistanceBottom: number;
  let pixelColor: string;
  let animationId: number | null = null;
  let resizeTimeout: number | undefined;
  let lastWidth = window.innerWidth;
  let pixels: { x: number; y: number; alpha: number }[] = [];
  let pixelSize = 20;
  let isAnimating = false;
  let scrollHandler: (() => void) | null = null;
  let resizeHandler: (() => void) | null = null;

  function getPixelSize(): number {
    return Math.floor(window.innerWidth / 5);
  }

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    pixelSize = getPixelSize();
  }

  function getProjectSectionPosition(): number | null {
    const projectSection = document.getElementById(targetId);
    if (!projectSection) return null;
    const rect = projectSection.getBoundingClientRect();
    return rect.top + window.scrollY;
  }

  function isInAnimationZone(): boolean {
    const scrollY = window.scrollY;
    const viewportHeight = window.innerHeight;
    const projectPos = getProjectSectionPosition();
    if (!projectPos) return false;

    const projectSection = document.getElementById(targetId);
    if (!projectSection) return false;

    const projectRect = projectSection.getBoundingClientRect();
    const projectEnd = projectRect.bottom + window.scrollY;
    const startZone = projectPos + topOffset - triggerDistance;

    // Si stopTargetId est défini, l'animation s'arrête quand cette section entre dans le viewport
    let endZone = projectEnd + bottomOffset;
    if (stopTargetId) {
      const stopSection = document.getElementById(stopTargetId);
      if (stopSection) {
        const stopRect = stopSection.getBoundingClientRect();
        const stopPos = stopRect.top + window.scrollY;
        endZone = stopPos + bottomOffset - viewportHeight;
      }
    }

    return (scrollY + viewportHeight) >= startZone && scrollY <= endZone;
  }

  function updatePixels() {
    const scrollY = window.scrollY;
    const viewportHeight = window.innerHeight;
    const projectPos = getProjectSectionPosition()! + topOffset;

    if (!projectPos) {
      pixels = [];
      return;
    }

    const projectSection = document.getElementById(targetId);
    if (!projectSection) {
      pixels = [];
      return;
    }

    const projectRect = projectSection.getBoundingClientRect();
    const distanceToProject = projectPos - (scrollY + viewportHeight);
    const progressIn = Math.max(0, Math.min(1, 1 - distanceToProject / triggerDistance));
    const finalProgress = progressIn;
    const isExitingTop = scrollY + viewportHeight < projectPos && progressIn < 1;

    if (finalProgress === 0) {
      pixels = [];
      return;
    }

    const cols = Math.floor(canvas.width / pixelSize) + 1;
    const rows = Math.floor(canvas.height / pixelSize) + 1;
    const maxPixels = cols * rows;
    const targetPixelCount = Math.floor(maxPixels * finalProgress);
    const occupiedPositions = new Set(pixels.map(p => `${p.x},${p.y}`));
    const availablePositions: {x: number, y: number}[] = [];

    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const x = col * pixelSize;
        const y = row * pixelSize;
        if (!occupiedPositions.has(`${x},${y}`)) {
          availablePositions.push({x, y});
        }
      }
    }

    availablePositions.sort((a, b) => {
      const randomWeight = 200;
      const scoreA = a.y - Math.random() * randomWeight;
      const scoreB = b.y - Math.random() * randomWeight;
      return scoreB - scoreA;
    });

    const pixelsToAdd = targetPixelCount - pixels.length;
    if (pixelsToAdd > 0) {
      for (let i = 0; i < Math.min(pixelsToAdd, availablePositions.length); i++) {
        pixels.push({
          x: availablePositions[i].x,
          y: availablePositions[i].y,
          alpha: 1
        });
      }
    } else if (pixelsToAdd < 0) {
      pixels.sort((a, b) => {
        const randomWeight = 200;
        if (isExitingTop) {
          const scoreA = -a.y + Math.random() * randomWeight;
          const scoreB = -b.y + Math.random() * randomWeight;
          return scoreA - scoreB;
        } else {
          const scoreA = a.y + Math.random() * randomWeight;
          const scoreB = b.y + Math.random() * randomWeight;
          return scoreA - scoreB;
        }
      });
      pixels.length = targetPixelCount;
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    pixels.forEach(pixel => {
      ctx.fillStyle = pixelColor;
      ctx.fillRect(pixel.x, pixel.y, pixelSize, pixelSize);
    });
  }

  function stopAnimation() {
    if (animationId !== null) {
      cancelAnimationFrame(animationId);
      animationId = null;
      isAnimating = false;
    }
  }

  function startAnimation() {
    if (!isAnimating) {
      isAnimating = true;
      animate();
    }
  }

  function animate() {
    if (!isInAnimationZone()) {
      // Clear canvas and stop animation when outside zone
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      pixels = [];
      stopAnimation();
      return;
    }

    updatePixels();
    draw();
    animationId = requestAnimationFrame(animate);
  }

  function checkAndToggleAnimation() {
    if (isInAnimationZone()) {
      startAnimation();
    }
  }

  function init() {
    // Annuler l'animation précédente si elle existe
    stopAnimation();

    // Récupérer le nouveau canvas
    canvas = document.getElementById('bg-canvas') as HTMLCanvasElement;
    if (!canvas) return;

    ctx = canvas.getContext('2d')!;
    targetId = canvas.getAttribute('data-target-id') || 'projects';
    stopTargetId = canvas.getAttribute('data-stop-target-id') || null;
    topOffset = Number(canvas.getAttribute('data-top-offset')) || 500;
    bottomOffset = Number(canvas.getAttribute('data-bottom-offset')) || -450;
    triggerDistance = Number(canvas.getAttribute('data-trigger-distance')) || 500;
    triggerDistanceBottom = Number(canvas.getAttribute('data-trigger-distance-bottom')) || 500;
    pixelColor = canvas.getAttribute('data-color') || 'rgb(244, 243, 243)';

    // Reset pixels
    pixels = [];
    lastWidth = window.innerWidth;

    resizeCanvas();
    checkAndToggleAnimation();
  }

  function cleanup() {
    stopAnimation();
    clearTimeout(resizeTimeout);
    if (scrollHandler) {
      window.removeEventListener('scroll', scrollHandler);
      scrollHandler = null;
    }
    if (resizeHandler) {
      window.removeEventListener('resize', resizeHandler);
      resizeHandler = null;
    }
  }

  function setupListeners() {
    // Cleanup anciens listeners
    if (scrollHandler) window.removeEventListener('scroll', scrollHandler);
    if (resizeHandler) window.removeEventListener('resize', resizeHandler);

    resizeHandler = () => {
      const currentWidth = window.innerWidth;
      if (currentWidth === lastWidth) return;

      lastWidth = currentWidth;
      clearTimeout(resizeTimeout);

      resizeTimeout = setTimeout(() => {
        resizeCanvas();
        pixels = [];
      }, 200);
    };

    scrollHandler = () => {
      if (!isAnimating) {
        checkAndToggleAnimation();
      }
    };

    window.addEventListener('resize', resizeHandler);
    window.addEventListener('scroll', scrollHandler, { passive: true });
  }

  // Initialisation au chargement
  init();
  setupListeners();

  // Cleanup avant view transition
  document.addEventListener('astro:before-swap', cleanup, { once: true });

  // Réinitialisation après une view transition
  document.addEventListener('astro:after-swap', () => {
    init();
    setupListeners();
  });
</script>
