---
interface Props {
	targetId?: string;
	topOffset?: number;
	bottomOffset?: number;
	triggerDistance?: number;
	triggerDistanceBottom?: number;
	color?: string;
}

const {
	targetId = 'page-content',
	topOffset = 500,
	bottomOffset = -450,
	triggerDistance = 500,
	triggerDistanceBottom = 500,
	color = 'rgb(244, 243, 243)'
} = Astro.props;
---

<canvas
	id="bg-canvas"
	class="fixed top-0 left-0 w-full min-h-lvh pointer-events-none -z-1000"
	data-target-id={targetId}
	data-top-offset={topOffset}
	data-bottom-offset={bottomOffset}
	data-trigger-distance={triggerDistance}
	data-trigger-distance-bottom={triggerDistanceBottom}
	data-color={color}
	aria-hidden="true"
	role="presentation"
></canvas>

<script>
  let canvas: HTMLCanvasElement;
  let ctx: CanvasRenderingContext2D;
  let targetId: string;
  let topOffset: number;
  let bottomOffset: number;
  let triggerDistance: number;
  let triggerDistanceBottom: number;
  let pixelColor: string;
  let animationId: number | null = null;
  let resizeTimeout: number | undefined;
  let lastWidth = window.innerWidth;
  let pixels: { x: number; y: number; alpha: number }[] = [];
  let pixelSize = 20;

  function getPixelSize(): number {
    return Math.floor(window.innerWidth / 5);
  }

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    pixelSize = getPixelSize();
  }

  function getProjectSectionPosition(): number | null {
    const projectSection = document.getElementById(targetId);
    if (!projectSection) return null;
    const rect = projectSection.getBoundingClientRect();
    return rect.top + window.scrollY;
  }

  function updatePixels() {
    const scrollY = window.scrollY;
    const viewportHeight = window.innerHeight;
    const projectPos = getProjectSectionPosition()! + topOffset;

    if (!projectPos) {
      pixels = [];
      return;
    }

    const projectSection = document.getElementById(targetId);
    if (!projectSection) {
      pixels = [];
      return;
    }

    const projectRect = projectSection.getBoundingClientRect();
    const projectEnd = projectRect.bottom + window.scrollY;
    const distanceToProject = projectPos - (scrollY + viewportHeight);
    const progressIn = Math.max(0, Math.min(1, 1 - distanceToProject / triggerDistance));
    const distanceAfterProject = scrollY - (projectEnd + bottomOffset);
    const progressOut = Math.max(0, Math.min(1, distanceAfterProject / triggerDistanceBottom));
    const finalProgress = progressIn * (1 - progressOut);
    const isExitingTop = scrollY + viewportHeight < projectPos && progressIn < 1;
    const isExitingBottom = scrollY > (projectEnd + bottomOffset);

    if (finalProgress === 0) {
      pixels = [];
      return;
    }

    const cols = Math.floor(canvas.width / pixelSize) + 1;
    const rows = Math.floor(canvas.height / pixelSize) + 1;
    const maxPixels = cols * rows;
    const targetPixelCount = Math.floor(maxPixels * finalProgress);
    const occupiedPositions = new Set(pixels.map(p => `${p.x},${p.y}`));
    const availablePositions: {x: number, y: number}[] = [];

    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const x = col * pixelSize;
        const y = row * pixelSize;
        if (!occupiedPositions.has(`${x},${y}`)) {
          availablePositions.push({x, y});
        }
      }
    }

    availablePositions.sort((a, b) => {
      const randomWeight = 200;
      if (isExitingBottom) {
        const scoreA = -a.y - Math.random() * randomWeight;
        const scoreB = -b.y - Math.random() * randomWeight;
        return scoreB - scoreA;
      } else {
        const scoreA = a.y - Math.random() * randomWeight;
        const scoreB = b.y - Math.random() * randomWeight;
        return scoreB - scoreA;
      }
    });

    const pixelsToAdd = targetPixelCount - pixels.length;
    if (pixelsToAdd > 0) {
      for (let i = 0; i < Math.min(pixelsToAdd, availablePositions.length); i++) {
        pixels.push({
          x: availablePositions[i].x,
          y: availablePositions[i].y,
          alpha: 1
        });
      }
    } else if (pixelsToAdd < 0) {
      pixels.sort((a, b) => {
        const randomWeight = 200;
        if (isExitingTop) {
          const scoreA = -a.y + Math.random() * randomWeight;
          const scoreB = -b.y + Math.random() * randomWeight;
          return scoreA - scoreB;
        } else {
          const scoreA = a.y + Math.random() * randomWeight;
          const scoreB = b.y + Math.random() * randomWeight;
          return scoreA - scoreB;
        }
      });
      pixels.length = targetPixelCount;
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    pixels.forEach(pixel => {
      ctx.fillStyle = pixelColor;
      ctx.fillRect(pixel.x, pixel.y, pixelSize, pixelSize);
    });
  }

  function animate() {
    updatePixels();
    draw();
    animationId = requestAnimationFrame(animate);
  }

  function init() {
    // Annuler l'animation précédente si elle existe
    if (animationId !== null) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }

    // Récupérer le nouveau canvas
    canvas = document.getElementById('bg-canvas') as HTMLCanvasElement;
    if (!canvas) return;

    ctx = canvas.getContext('2d')!;
    targetId = canvas.getAttribute('data-target-id') || 'projects';
    topOffset = Number(canvas.getAttribute('data-top-offset')) || 500;
    bottomOffset = Number(canvas.getAttribute('data-bottom-offset')) || -450;
    triggerDistance = Number(canvas.getAttribute('data-trigger-distance')) || 500;
    triggerDistanceBottom = Number(canvas.getAttribute('data-trigger-distance-bottom')) || 500;
    pixelColor = canvas.getAttribute('data-color') || 'rgb(244, 243, 243)';

    // Reset pixels
    pixels = [];
    lastWidth = window.innerWidth;

    resizeCanvas();
    animate();
  }

  window.addEventListener('resize', () => {
    const currentWidth = window.innerWidth;
    if (currentWidth === lastWidth) return;

    lastWidth = currentWidth;
    clearTimeout(resizeTimeout);

    resizeTimeout = setTimeout(() => {
      resizeCanvas();
      pixels = [];
    }, 200);
  });

  // Initialisation au chargement
  init();

  // Réinitialisation après une view transition
  document.addEventListener('astro:after-swap', init);
</script>
