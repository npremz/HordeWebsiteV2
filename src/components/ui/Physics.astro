---
interface Props {
  class?: string;
}

const { class: className = '' } = Astro.props;
---

<div id="physics-container" class:list={['physics-grid w-full aspect-square md:aspect-2/1 relative overflow-hidden', className]}>
  <div id="logo-letters" class="absolute inset-0" aria-hidden="true" role="presentation">
    <svg class="physics-letter" width="134" height="66" viewBox="0 0 134 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0L133.486 0V65.9931L0 65.9931L0 0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="132" height="134" viewBox="0 0 132 134" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M131.986 0V66.743L65.9931 66.743L65.9931 133.486H0L0 0L131.986 0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="66" height="66" viewBox="0 0 66 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0H65.9931V65.9931H0V0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="200" height="66" viewBox="0 0 200 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0L199.479 0V65.9931L0 65.9931L0 0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="134" height="66" viewBox="0 0 134 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0L133.486 0V65.9931L0 65.9931L0 0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="132" height="134" viewBox="0 0 132 134" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M131.986 0V66.743L65.9931 66.743L65.9931 133.486H0L0 0L131.986 0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="66" height="66" viewBox="0 0 66 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0H65.9931V65.9931H0V0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="200" height="66" viewBox="0 0 200 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0L199.479 0V65.9931L0 65.9931L0 0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="134" height="66" viewBox="0 0 134 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0L133.486 0V65.9931L0 65.9931L0 0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="132" height="134" viewBox="0 0 132 134" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M131.986 0V66.743L65.9931 66.743L65.9931 133.486H0L0 0L131.986 0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="66" height="66" viewBox="0 0 66 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0H65.9931V65.9931H0V0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="200" height="66" viewBox="0 0 200 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0L199.479 0V65.9931L0 65.9931L0 0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="134" height="66" viewBox="0 0 134 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0L133.486 0V65.9931L0 65.9931L0 0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="132" height="134" viewBox="0 0 132 134" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M131.986 0V66.743L65.9931 66.743L65.9931 133.486H0L0 0L131.986 0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="66" height="66" viewBox="0 0 66 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0H65.9931V65.9931H0V0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="200" height="66" viewBox="0 0 200 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0L199.479 0V65.9931L0 65.9931L0 0Z" fill="#222121"/>
    </svg>
        <svg class="physics-letter" width="134" height="66" viewBox="0 0 134 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0L133.486 0V65.9931L0 65.9931L0 0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="132" height="134" viewBox="0 0 132 134" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M131.986 0V66.743L65.9931 66.743L65.9931 133.486H0L0 0L131.986 0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="66" height="66" viewBox="0 0 66 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0H65.9931V65.9931H0V0Z" fill="#222121"/>
    </svg>
    <svg class="physics-letter" width="200" height="66" viewBox="0 0 200 66" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0L199.479 0V65.9931L0 65.9931L0 0Z" fill="#222121"/>
    </svg>
  </div>
</div>

<style>
  .physics-grid {
    --grid-color: var(--color-bg);
    --grid-cols: 6;
    --grid-rows: 6;
    background-image:
      linear-gradient(to right, var(--grid-color) 1px, transparent 1px),
      linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
    background-size: calc(100% / var(--grid-cols)) calc(100% / var(--grid-rows));
    background-position: 0 0;
  }

  /* md: aspect-2/1 (2:1) */
  @media (min-width: 1024px) {
    .physics-grid {
      --grid-cols: 13;
      --grid-rows: 7;
    }
  }

  /* xl: aspect-3/1 (3:1) */
  @media (min-width: 1920px) {
    .physics-grid {
      --grid-cols: 13;
      --grid-rows: 7;
    }
  }

  .physics-grid::after {
    content: '';
    position: absolute;
    inset: 0;
    border: 1px solid var(--grid-color);
    pointer-events: none;
    z-index: 10;
  }

  .physics-letter {
    position: absolute;
    will-change: transform;
    pointer-events: none;
    opacity: 0;
  }

  .physics-letter.physics-ready {
    opacity: 1;
  }
</style>

<script>
  import Matter from 'matter-js';

  const { Engine, Bodies, Composite, Body, Mouse, MouseConstraint } = Matter;

  // Détecter si c'est un device avec pointeur (souris)
  const hasPointer = window.matchMedia('(pointer: fine)').matches;

  function initPhysics() {
    const container = document.getElementById('physics-container');
    const letters = document.querySelectorAll<SVGSVGElement>('.physics-letter');

    if (!container || letters.length === 0) return;

    // Reset les classes et cacher les lettres
    letters.forEach((letter) => letter.classList.remove('physics-ready'));

    // Nettoyer l'ancien canvas si existant
    const oldCanvas = container.querySelector('canvas');
    if (oldCanvas) oldCanvas.remove();

    const rect = container.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;

    // Scale proportionnel au container
    const baseScale = width / 1200;
    const scale = Math.max(0.3, Math.min(1, baseScale));

    // Créer le moteur
    const engine = Engine.create();
    const world = engine.world;

    // Gravité
    engine.gravity.y = 1;

    // Épaisseur des murs (renforcés pour éviter les explosions)
    const wallThickness = 200;

    // Créer le bowl (murs gauche, droite, bas) - renforcés
    const walls = [
      // Mur gauche
      Bodies.rectangle(
        -wallThickness / 2,
        height / 2,
        wallThickness,
        height * 3,
        { isStatic: true, friction: 1, restitution: 0.2 }
      ),
      // Mur droite
      Bodies.rectangle(
        width + wallThickness / 2,
        height / 2,
        wallThickness,
        height * 3,
        { isStatic: true, friction: 1, restitution: 0.2 }
      ),
      // Mur bas
      Bodies.rectangle(
        width / 2,
        height + wallThickness / 2,
        width + wallThickness * 2,
        wallThickness,
        { isStatic: true, friction: 1, restitution: 0.2 }
      ),
    ];

    Composite.add(world, walls);

    // Drag & drop pour devices avec souris
    if (hasPointer) {
      // Créer un canvas invisible pour le tracking de la souris
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      canvas.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:auto;opacity:0;cursor:grab;';
      container.appendChild(canvas);

      const mouse = Mouse.create(canvas);
      const mouseConstraint = MouseConstraint.create(engine, {
        mouse: mouse,
        constraint: {
          stiffness: 0.2,
          render: { visible: false }
        }
      });

      // Limiter la force du drag pour éviter les explosions
      mouseConstraint.constraint.damping = 0.5;

      Composite.add(world, mouseConstraint);

      // Changer le curseur au survol/drag
      canvas.addEventListener('mousedown', () => { canvas.style.cursor = 'grabbing'; });
      canvas.addEventListener('mouseup', () => { canvas.style.cursor = 'grab'; });
    }

    // Créer les corps pour chaque lettre avec leurs dimensions propres
    const bodies: Matter.Body[] = [];
    const dimensions: { width: number; height: number; offsetX: number; offsetY: number }[] = [];

    letters.forEach((letter, index) => {
      // Lire les dimensions originales du SVG
      const originalWidth = parseFloat(letter.getAttribute('width') || '100');
      const originalHeight = parseFloat(letter.getAttribute('height') || '100');

      // Détecter la forme en L (132x134) - comparaison arrondie pour éviter les problèmes de parsing
      const isLShape = Math.round(originalWidth) === 132 && Math.round(originalHeight) === 134;

      // Appliquer le scale
      const letterWidth = originalWidth * scale;
      const letterHeight = originalHeight * scale;

      // Offset pour compenser le décalage du centre de masse (pour les formes en L)
      // Le centre de masse du L est décalé vers le haut-droite, donc on compense
      const offsetX = isLShape ? 11 * scale : 0;
      const offsetY = isLShape ? 11 * scale : 0;

      dimensions.push({ width: letterWidth, height: letterHeight, offsetX, offsetY });

      // Position initiale au-dessus du container, espacée
      const x = (width / 2) + (Math.random() - 0.5) * width * 0.6;
      const y = -letterHeight - (index * 80 * scale) - Math.random() * 100;

      let body: Matter.Body;

      if (isLShape) {
        // Créer un compound body pour la forme en L
        // Rectangle horizontal en haut: 132 x 67
        const topWidth = 132 * scale;
        const topHeight = 67 * scale;
        // Rectangle vertical en bas à gauche: 66 x 67
        const bottomWidth = 66 * scale;
        const bottomHeight = 67 * scale;

        // Positions relatives au centre du L
        // Centre du L est approximativement à (66, 67)
        const centerX = 66 * scale;
        const centerY = 67 * scale;

        const topPart = Bodies.rectangle(
          (66 * scale) - centerX,  // centré horizontalement sur le rectangle du haut
          (33.5 * scale) - centerY, // centré verticalement sur le rectangle du haut
          topWidth,
          topHeight
        );

        const bottomPart = Bodies.rectangle(
          (33 * scale) - centerX,   // centré horizontalement sur le rectangle du bas
          (100.5 * scale) - centerY, // centré verticalement sur le rectangle du bas
          bottomWidth,
          bottomHeight
        );

        body = Body.create({
          parts: [topPart, bottomPart],
          restitution: 0.3,
          friction: 0.5,
          frictionAir: 0.01,
        });

        Body.setPosition(body, { x, y });
        Body.setAngle(body, (Math.random() - 0.5) * 0.5);
      } else {
        // Corps rectangle simple pour les autres formes
        body = Bodies.rectangle(x, y, letterWidth, letterHeight, {
          restitution: 0.3,
          friction: 0.5,
          frictionAir: 0.01,
          angle: (Math.random() - 0.5) * 0.5,
        });
      }

      bodies.push(body);
      Composite.add(world, body);

      // Appliquer l'échelle au SVG
      letter.style.width = `${letterWidth}px`;
      letter.style.height = `${letterHeight}px`;
    });

    // Boucle de rendu
    function update() {
      Engine.update(engine, 1000 / 60);

      bodies.forEach((body, index) => {
        const letter = letters[index];
        const dim = dimensions[index];
        if (letter && dim) {
          const angle = body.angle;

          // Transformer l'offset selon l'angle du corps
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          const rotatedOffsetX = dim.offsetX * cos - dim.offsetY * sin;
          const rotatedOffsetY = dim.offsetX * sin + dim.offsetY * cos;

          const x = body.position.x - dim.width / 2 + rotatedOffsetX;
          const y = body.position.y - dim.height / 2 + rotatedOffsetY;

          letter.style.transform = `translate(${x}px, ${y}px) rotate(${angle}rad)`;
          
          // Rendre visible une fois positionné
          if (!letter.classList.contains('physics-ready')) {
            letter.classList.add('physics-ready');
          }
        }
      });

      requestAnimationFrame(update);
    }

    update();
  }

  // Observer pour déclencher quand le container est visible
  let hasTriggered = false;
  let observer: IntersectionObserver | null = null;

  function setupObserver() {
    const container = document.getElementById('physics-container');
    if (!container) return;

    hasTriggered = false;

    // Cleanup ancien observer
    if (observer) observer.disconnect();

    observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && !hasTriggered) {
            hasTriggered = true;
            initPhysics();
            observer?.disconnect();
          }
        });
      },
      { threshold: 0.1, rootMargin: '-400px 0px' }
    );

    observer.observe(container);
  }

  // Init au chargement
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupObserver);
  } else {
    setupObserver();
  }

  // Re-init sur les view transitions
  document.addEventListener('astro:after-swap', setupObserver);

  // Re-init uniquement sur resize horizontal (évite les problèmes sur mobile)
  let lastWidth = window.innerWidth;
  let resizeTimeout: ReturnType<typeof setTimeout>;
  
  window.addEventListener('resize', () => {
    const currentWidth = window.innerWidth;
    if (currentWidth !== lastWidth) {
      lastWidth = currentWidth;
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        hasTriggered = false;
        setupObserver();
      }, 150);
    }
  });
</script>
