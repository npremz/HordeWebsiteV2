---
import { DEFAULT_LOCALE, type Locale, useTranslations } from '../../i18n';

interface Props {
	lang?: Locale;
}

const { lang = DEFAULT_LOCALE } = Astro.props;
const t = useTranslations(lang);
const methods = t.method.methods;
---

<div id="methods-container" class="flex flex-col pt-64 scroll-mt-[150px]">
	<!-- SVG flottant qui suit la souris -->
	<div id="methods-hover-svg" class="pointer-events-none fixed z-[200] overflow-visible" style="transform: translate(-50%, -50%) scale(0) rotate(-180deg); will-change: transform;">
		<svg class="overflow-visible min-w-[500px] min-h-[500px]" width="516" height="516" viewBox="0 0 516 516" fill="none" xmlns="http://www.w3.org/2000/svg">
			<path d="M7.96289 3.53809H507.845V0.000976562H515.808V7.96289H511.935V507.846H515.808V515.809H507.845V511.91H7.96289V515.808H0V507.845H3.5625V7.96289H0V0H7.96289V3.53809ZM7.96289 7.96289H4.5625V507.845H7.96289V510.91H507.845V507.846H510.935V7.96289H507.845V4.53809H7.96289V7.96289ZM259.018 16.2969C391.479 17.136 498.601 124.776 498.601 257.436L498.596 258.995C497.757 391.457 390.117 498.578 257.458 498.578L255.898 498.573C123.956 497.738 17.1551 390.938 16.3193 258.995L16.3145 257.436C16.3145 124.256 124.278 16.292 257.458 16.292L259.018 16.2969ZM257.458 17.292C124.831 17.292 17.3145 124.808 17.3145 257.436C17.3146 390.063 124.831 497.578 257.458 497.578C390.085 497.578 497.6 390.063 497.601 257.436C497.601 124.808 390.085 17.2921 257.458 17.292ZM267.667 249.373L264.417 252.623C265.544 254.053 266.194 255.874 266.194 257.78C266.194 259.774 265.587 261.593 264.547 263.066L267.667 266.187L265.761 268.05L262.641 264.974C261.167 266.1 259.304 266.75 257.268 266.75C255.274 266.75 253.498 266.1 252.024 264.974L248.947 268.05L247.084 266.187L250.204 263.066C249.121 261.55 248.514 259.73 248.514 257.78C248.514 255.83 249.164 254.053 250.291 252.58L247.084 249.373L248.947 247.467L252.197 250.717C253.627 249.677 255.404 249.07 257.268 249.07C259.217 249.07 261.037 249.677 262.511 250.717L265.761 247.467L267.667 249.373ZM257.268 251.627C253.931 251.627 251.07 254.444 251.07 257.78C251.07 261.377 253.888 264.193 257.268 264.193C260.777 264.193 263.638 261.377 263.638 257.78C263.638 254.444 260.777 251.627 257.268 251.627Z" fill="#B1B1B1"/>
		</svg>
	</div>
	<div class="flex justify-between items-end">
		<h2 class="methods-title font-display uppercase leading-none text-4xl sm:text-[3.25rem] md:text-[4.875rem] lg:text-[6.875rem] xl:text-[7.5rem]" set:html={t.method.title.replace(/\n/g, '<br>')} />
		<div class="font-display text-[1.625rem] sm:text-[2.5rem] md:text-[4rem]">(↓)</div>
	</div>
	<ol class="methods-stack flex flex-col mt-10 sm:mt-16 xl:mt-24">
		{methods.map((method, index) => (
			<li
				class:list={[
					'method-card',
					index >= 1 && 'full-width-bg',
					'py-10 sm:py-16 -mt-px',
					'relative'
				]}
				style={`z-index: ${methods.length - index}`}
				data-index={index}
				id={index === 1 ? 'method-transition' : undefined}
			>
				<div class="method-card-inner">
					<article class:list={[
						"flex flex-col md:flex-row md:justify-between",
						index == 2 && 'pb-10 sm:pb-32',
						index != 2 && 'pb-10 sm:pb-16',
					]}>
						<header class="flex flex-col gap-2 sm:gap-8">
							<div class:list={["section-label max-w-[210px] text-justify", index === 2 && "md:min-h-[2lh]"]}>
								<span class='inline before:content-["/_"]'>{method.number}</span>
								<p class="inline">{method.eyebrow}</p>
							</div>
							<h3 class="font-display leading-none text-[1.625rem] sm:text-[2.5rem] md:text-[4rem] sm:max-w-[250px] md:max-w-[350px] uppercase" set:html={method.title}></h3>
						</header>
						<div class="flex flex-col md:w-1/2">
							<blockquote class='section-label mt-16 max-w-90 self-end sm:mt-24 md:self-start md:mt-0'>"{method.quote}"</blockquote>
							<p class="text-2xl sm:text-[2rem] mt-4 sm:mt-8 ">{method.description}</p>
						</div>
					</article>
				</div>
				{index != 2 && (
					<div class="method-line border-b border-lines"></div>
				)}
			</li>
		))}
	</ol>
	<div class="full-width-bg relative z-[100] -mt-px flex">
		<a
			href={`/${lang}/contact`}
			class="group relative overflow-hidden font-mono text-[1rem] leading-none uppercase py-6 px-5 flex justify-center w-full md:w-fit md:ml-auto border border-lines-dark bg-transparent text-black transition-colors duration-300 ease-in-out cursor-pointer"
		>
			<span class="absolute inset-0 bg-black translate-x-[calc(-100%-1px)] group-hover:translate-x-0 transition-transform duration-400 ease-[cubic-bezier(0.25,0.46,0.45,0.94)]" />
			<span class="relative z-10 group-hover:text-bg-light transition-colors duration-300">
				{t.method.contact}
			</span>
		</a>
	</div>
</div>

<style>
	.method-card {
		will-change: transform;
	}

	.method-card-inner {
		will-change: transform;
	}

	.method-line {
		will-change: transform;
	}

	.methods-title {
		will-change: transform;
	}
</style>

<script>
	function initMethodsParallax() {
		const cards = document.querySelectorAll('.method-card');
		if (cards.length === 0) return;

		// Offset initial par carte (en pixels) - plus grand = plus de retard
		const initialOffsets = [100, 200, 280];
		// Offset pour les lignes - valeurs positives = ligne commence plus bas
		const lineOffsets = [250, 300, 0]; // La dernière carte n'a pas de ligne

		// Fonction d'easing (ease-out cubic)
		function easeOutCubic(t: number): number {
			return 1 - Math.pow(1 - t, 3);
		}

		function updateCards() {
			const viewportHeight = window.innerHeight;

			cards.forEach((card, index) => {
				const cardElement = card as HTMLElement;
				const rect = cardElement.getBoundingClientRect();

				// Quand la carte entre dans le viewport par le bas
				// Progress: 0 = carte en bas du viewport, 1 = carte en haut
				const distanceFromBottom = viewportHeight - rect.top;
				const travelDistance = viewportHeight + rect.height;
				const rawProgress = Math.max(0, Math.min(1, distanceFromBottom / travelDistance));

				// Appliquer easing
				const progress = easeOutCubic(rawProgress);

				// Animer le contenu
				const initialOffset = initialOffsets[index] || 0;
				if (initialOffset > 0) {
					const currentOffset = initialOffset * (1 - progress);
					const inner = cardElement.querySelector('.method-card-inner') as HTMLElement;
					if (inner) {
						inner.style.transform = `translateY(${currentOffset}px)`;
					}
				}

				// Animer la ligne
				const lineOffset = lineOffsets[index] || 0;
				if (lineOffset !== 0) {
					const currentLineOffset = lineOffset * (1 - progress);
					const line = cardElement.querySelector('.method-line') as HTMLElement;
					if (line) {
						line.style.transform = `translateY(${currentLineOffset}px)`;
					}
				}
			});

		}

		// Écouter le scroll
		let ticking = false;
		function onScroll() {
			if (!ticking) {
				requestAnimationFrame(() => {
					updateCards();
					ticking = false;
				});
				ticking = true;
			}
		}

		window.addEventListener('scroll', onScroll, { passive: true });
		updateCards();

		// Cleanup pour les view transitions
		document.addEventListener('astro:before-swap', () => {
			window.removeEventListener('scroll', onScroll);
		}, { once: true });
	}

	initMethodsParallax();
	document.addEventListener('astro:after-swap', initMethodsParallax);

	// SVG hover follow
	function initMethodsSvgHover() {
		const container = document.getElementById('methods-hover-svg');
		const methodsStack = document.querySelector('.methods-stack');

		if (!container || !methodsStack) return;

		let mouseX = 0;
		let mouseY = 0;
		let currentX = 0;
		let currentY = 0;
		let velocityX = 0;
		let currentRotation = -180;
		let currentScale = 0;
		let targetScale = 0;
		let targetRotation = -180;
		let exitRotation = -180;
		let isHovering = false;
		let animationId: number | null = null;

		function animate() {
			const posEase = 0.1;
			const scaleEase = 0.05;
			const rotEase = 0.05;

			// Position
			const prevX = currentX;
			currentX += (mouseX - currentX) * posEase;
			currentY += (mouseY - currentY) * posEase;

			// Vélocité pour l'inertie
			velocityX = currentX - prevX;

			// Inertie : rotation basée sur la vélocité (max ±15deg)
			const inertiaRotation = Math.max(-15, Math.min(15, velocityX * 3));
			targetRotation = isHovering ? inertiaRotation : exitRotation;

			// Scale
			currentScale += (targetScale - currentScale) * scaleEase;

			// Rotation avec inertie
			currentRotation += (targetRotation - currentRotation) * rotEase;

			container.style.left = `${currentX}px`;
			container.style.top = `${currentY}px`;
			container.style.transform = `translate(-50%, -50%) scale(${currentScale}) rotate(${currentRotation}deg)`;

			// Stop animation when scale is nearly 0 and not hovering
			if (!isHovering && currentScale < 0.01) {
				currentScale = 0;
				animationId = null;
				return;
			}

			const isAnimating =
				Math.abs(currentX - mouseX) > 0.1 ||
				Math.abs(currentY - mouseY) > 0.1 ||
				Math.abs(currentScale - targetScale) > 0.01 ||
				Math.abs(currentRotation - targetRotation) > 0.1;

			if (isAnimating) {
				animationId = requestAnimationFrame(animate);
			} else {
				animationId = null;
			}
		}

		function startAnimation() {
			if (!animationId) {
				animationId = requestAnimationFrame(animate);
			}
		}

		// Zone de hover = toute la largeur viewport, hauteur du ol
		function isInMethodsSection(clientY: number) {
			const rect = methodsStack.getBoundingClientRect();
			// Seulement basé sur Y - toute la largeur du viewport
			return clientY >= rect.top && clientY <= rect.bottom;
		}

		document.addEventListener('mousemove', (e) => {
			const wasHovering = isHovering;
			isHovering = isInMethodsSection(e.clientY);

			mouseX = e.clientX;
			mouseY = e.clientY;

			if (isHovering && !wasHovering) {
				// Apparition - position immédiate
				currentX = mouseX;
				currentY = mouseY;
				currentRotation = -180;
				currentScale = 0;
				document.body.style.cursor = 'none';
			} else if (!isHovering && wasHovering) {
				// Fixer la rotation de sortie à la rotation actuelle - 180
				exitRotation = currentRotation - 180;
				document.body.style.cursor = '';
			}

			targetScale = isHovering ? 1 : 0;
			startAnimation();
		});

		document.addEventListener('mouseleave', () => {
			isHovering = false;
			targetScale = 0;
			exitRotation = currentRotation - 180;
			document.body.style.cursor = '';
			startAnimation();
		});

		// Cleanup
		document.addEventListener('astro:before-swap', () => {
			if (animationId) {
				cancelAnimationFrame(animationId);
			}
		}, { once: true });
	}

	initMethodsSvgHover();
	document.addEventListener('astro:after-swap', initMethodsSvgHover);
</script>
