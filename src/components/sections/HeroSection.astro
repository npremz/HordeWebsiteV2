---
import Line from "../ui/Line.astro";
import Wrapped from "../ui/Wrapped.astro";

interface Props {
	titleLine1?: string;
	titleLine2?: string;
	titleLine3Prefix?: string;
	ctaLabel?: string;
	scrollTarget?: string;
}

const {
	titleLine1 = "Nous\nconcevons",
	titleLine2 = "des",
	titleLine3Prefix = "interfaces",
	ctaLabel = "Notre methode",
	scrollTarget = "#page-content",
} = Astro.props;

const typewriterWords = [
	"ultra rapides",
	"optimisees",
	"user friendly",
	"soignees",
];
---

<section class="relative h-svh -z-9998">
	<div class="relative top-1/2 -translate-y-1/2 sm:top-2/5 md:top-1/2 mt-10">
		<div class="hidden md:flex justify-end mb-6">
			<div
				class="flex gap-8 md:gap-16 lg:gap-24 font-mono text-[1rem] uppercase"
			>
				<div class="flex flex-col gap-1">
					<span id="hero-time">MAR --:--:--</span>
					<span id="hero-weather"
						>BXL --° <span
							class="font-neuebit text-[1.75rem] inline-block leading-[0] relative -top-[-3px]"
							>☁</span
						></span
					>
				</div>
				<div class="flex flex-col gap-1">
					<span>Agence Digitale</span>
					<span>UX à Bruxelles</span>
				</div>
			</div>
		</div>
		<h1
			class="font-display uppercase leading-[0.9] text-4xl sm:text-[3.25rem] md:text-[4.875rem] lg:text-[6.875rem] xl:text-[7.5rem]"
		>
			<span
				class="block mb-2"
				set:html={titleLine1.replace(/\n/g, "<br>")}
			/>
			<svg
				class="hidden sm:block lg:hidden -z-10 absolute w-[calc(100%-2*1rem)] -translate-y-[51%] center-x"
				viewBox="0 0 531 883"
				fill="none"
				xmlns="http://www.w3.org/2000/svg"
			>
				<rect
					x="-0.5"
					y="0.5"
					width="298.273"
					height="298.273"
					rx="149.136"
					transform="matrix(-1 -8.74228e-08 -8.74228e-08 1 414.272 457.887)"
					stroke="#B1B1B1"></rect>
				<rect
					x="-0.5"
					y="0.5"
					width="298.273"
					height="298.273"
					rx="149.136"
					transform="matrix(-1 -8.74228e-08 -8.74228e-08 1 414.272 143)"
					stroke="#B1B1B1"></rect>
				<rect
					x="414.772"
					y="607.023"
					width="298.273"
					height="312.586"
					transform="rotate(-180 414.772 607.023)"
					stroke="#B1B1B1"></rect>
				<path
					d="M530.5 0.5V617.5C530.5 763.855 411.855 882.5 265.5 882.5C119.145 882.5 0.500002 763.855 0.5 617.5V0.5H530.5Z"
					stroke="#B1B1B1"></path>
			</svg>
			<svg
				class="hidden lg:block -z-10 absolute w-[calc(100%-2*1.5rem)] -translate-y-[54%] center-x"
				viewBox="0 0 1218 1282"
				fill="none"
				xmlns="http://www.w3.org/2000/svg"
			>
				<rect
					x="0.5"
					y="0.5"
					width="379.504"
					height="379.504"
					rx="189.752"
					transform="matrix(-4.37114e-08 1 1 4.37114e-08 619.356 498.087)"
					stroke="#B1B1B1"></rect>
				<rect
					x="0.5"
					y="0.5"
					width="379.504"
					height="379.504"
					rx="189.752"
					transform="matrix(-4.37114e-08 1 1 4.37114e-08 219 498.087)"
					stroke="#B1B1B1"></rect>
				<rect
					x="809.108"
					y="498.587"
					width="379.504"
					height="397.702"
					transform="rotate(90 809.108 498.587)"
					stroke="#B1B1B1"></rect>
				<path
					d="M1217.5 0.5V673C1217.5 1009.07 945.065 1281.5 609 1281.5C272.935 1281.5 0.500003 1009.07 0.5 673V0.5H1217.5Z"
					stroke="#B1B1B1"></path>
			</svg>
			<Line dotClass="z-9999" />
			<span class="block text-right">
				{titleLine2}<br />
				{titleLine3Prefix}<br />
				<span class="word-rotator">
					<span class="word-rotator-inner">
						{
							typewriterWords.map((word) => (
								<span class="word-rotator-word">{word}</span>
							))
						}
						<span class="word-rotator-word"
							>{typewriterWords[0]}</span
						>
					</span>
				</span>
			</span>
		</h1>
		<button
			class="hidden md:block mt-4 sm:mt-8 font-mono uppercase text-[1rem] cursor-pointer scroll-to-btn"
			data-scroll-target={scrollTarget}
			><Wrapped class="text-[1rem]">↓</Wrapped></button
		>
	</div>
	<button
		class="md:hidden absolute mt-0 bottom-8 left-1/2 -translate-x-1/2 sm:left-0 sm:translate-0 font-mono uppercase text-[1rem] sm:bottom-24 md:relative md:bottom-0 cursor-pointer scroll-to-btn"
		data-scroll-target={scrollTarget}
		><Wrapped class="text-[1rem]">↓</Wrapped></button
	>
</section>

<script>
	const days = ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"];
	const weatherCodes: Record<number, [string, string]> = {
		0: ["Ensoleillé", "☀"],
		1: ["Peu nuageux", "⛅"],
		2: ["Partiellement nuageux", "☁"],
		3: ["Couvert", "☁"],
		45: ["Brouillard", "☁"],
		48: ["Brouillard givrant", "☁"],
		51: ["Bruine légère", "☂"],
		53: ["Bruine modérée", "☂"],
		55: ["Bruine dense", "☂"],
		61: ["Pluie légère", "☂"],
		63: ["Pluie modérée", "☂"],
		65: ["Pluie forte", "☂"],
		71: ["Neige légère", "❄"],
		73: ["Neige modérée", "❄"],
		75: ["Neige forte", "❄"],
		77: ["Grésil", "❄"],
		80: ["Averses légères", "☂"],
		81: ["Averses modérées", "☂"],
		82: ["Averses violentes", "☂"],
		95: ["Orage", "⚡"],
		96: ["Orage avec grêle", "⚡"],
		99: ["Orage violent", "⚡"],
	};

	let timeIntervalId: number | null = null;
	let weatherIntervalId: number | null = null;

	function formatTime(date: Date) {
		const dayName = days[date.getDay()];
		const hours = date.getHours().toString().padStart(2, "0");
		const minutes = date.getMinutes().toString().padStart(2, "0");
		const seconds = date.getSeconds().toString().padStart(2, "0");
		return `${dayName}    (${hours}:${minutes}:${seconds})`;
	}

	function updateTime() {
		const timeEl = document.getElementById("hero-time");
		if (timeEl) {
			timeEl.textContent = formatTime(new Date());
		}
	}

	async function fetchWeather() {
		const weatherEl = document.getElementById("hero-weather");
		if (!weatherEl) return;

		try {
			const controller = new AbortController();
			const timeoutId = setTimeout(() => controller.abort(), 5000); // 5s timeout

			const response = await fetch(
				"https://api.open-meteo.com/v1/forecast?latitude=50.8503&longitude=4.3517&current_weather=true",
				{ signal: controller.signal },
			);
			clearTimeout(timeoutId);

			const data = await response.json();
			const temp = Math.round(data.current_weather.temperature);
			const code = data.current_weather.weathercode;
			const weatherInfo = weatherCodes[code] || ["--", "☁"];

			weatherEl.innerHTML = `${temp}° ${weatherInfo[0]} <span class="font-neuebit text-[1.75rem] inline-block leading-[0] relative -top-[-3px]">${weatherInfo[1]}</span>`;
		} catch {
			// Garder le placeholder en cas d'erreur - pas de console.error pour éviter le bruit
		}
	}

	function cleanup() {
		if (timeIntervalId) {
			clearInterval(timeIntervalId);
			timeIntervalId = null;
		}
		if (weatherIntervalId) {
			clearInterval(weatherIntervalId);
			weatherIntervalId = null;
		}
	}

	function init() {
		cleanup();
		updateTime();
		timeIntervalId = window.setInterval(updateTime, 1000);

		// Fetch météo uniquement sur desktop (md: 1024px+) où c'est affiché
		const isDesktop = window.matchMedia("(min-width: 1024px)").matches;
		if (isDesktop) {
			if ("requestIdleCallback" in window) {
				requestIdleCallback(
					() => {
						fetchWeather();
						weatherIntervalId = window.setInterval(
							fetchWeather,
							1000 * 60 * 15,
						);
					},
					{ timeout: 3000 },
				);
			} else {
				setTimeout(() => {
					fetchWeather();
					weatherIntervalId = window.setInterval(
						fetchWeather,
						1000 * 60 * 15,
					);
				}, 1500);
			}
		}
	}

	if (document.readyState === "complete") {
		init();
	} else {
		window.addEventListener("load", init, { once: true });
	}

	document.addEventListener("astro:after-swap", () => {
		setTimeout(init, 50);
	});
</script>

<script>
	let rotatorIntervalId: number | null = null;
	let currentIndex = 0;

	function initWordRotator() {
		const inner = document.querySelector(
			".word-rotator-inner",
		) as HTMLElement;
		const words = document.querySelectorAll(".word-rotator-word");

		if (!inner || words.length === 0) return;

		const totalWords = words.length - 1; // -1 car le dernier est un clone du premier
		currentIndex = 0;
		inner.style.transform = "translateY(0)";

		rotatorIntervalId = window.setInterval(() => {
			currentIndex++;
			inner.style.transform = `translateY(calc(-${currentIndex} * 1em))`;

			// Quand on atteint le clone, reset instantané vers le vrai premier
			if (currentIndex >= totalWords) {
				setTimeout(() => {
					inner.style.transition = "none";
					inner.style.transform = "translateY(0)";
					currentIndex = 0;
					// Force reflow puis réactive la transition
					inner.offsetHeight;
					inner.style.transition = "";
				}, 500); // Attendre la fin de la transition
			}
		}, 2500);
	}

	function cleanupWordRotator() {
		if (rotatorIntervalId) {
			clearInterval(rotatorIntervalId);
			rotatorIntervalId = null;
		}
	}

	// Initialize
	if (document.readyState === "complete") {
		initWordRotator();
	} else {
		window.addEventListener("load", initWordRotator, { once: true });
	}

	// Cleanup on navigation
	document.addEventListener("astro:before-swap", cleanupWordRotator, {
		once: true,
	});

	// Re-init after navigation
	document.addEventListener("astro:after-swap", initWordRotator);
</script>

<script>
	function initScrollButtons() {
		const scrollButtons = document.querySelectorAll(".scroll-to-btn");

		scrollButtons.forEach((btn) => {
			btn.addEventListener("click", () => {
				const target = btn.getAttribute("data-scroll-target");
				if (target && (window as any).lenis) {
					(window as any).lenis.scrollTo(target, { duration: 1.2 });
				}
			});
		});
	}

	initScrollButtons();
	document.addEventListener("astro:after-swap", initScrollButtons);
</script>

<style is:global>
	.word-rotator {
		display: inline-block;
		height: 1em;
		line-height: 1;
		overflow: hidden;
		vertical-align: bottom;
	}

	.word-rotator-inner {
		display: flex;
		flex-direction: column;
		transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
	}

	.word-rotator-word {
		display: block;
		height: 1em;
		line-height: 1;
		flex-shrink: 0;
	}
</style>
